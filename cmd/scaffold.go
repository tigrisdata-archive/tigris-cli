// Copyright 2022-2023 Tigris Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/tigrisdata/tigris-cli/client"
	"github.com/tigrisdata/tigris-cli/config"
	login "github.com/tigrisdata/tigris-cli/login"
	"github.com/tigrisdata/tigris-cli/scaffold"
	"github.com/tigrisdata/tigris-cli/util"
	api "github.com/tigrisdata/tigris-client-go/api/server/v1"
	"github.com/tigrisdata/tigris-client-go/driver"
)

var (
	outDir  string
	pkgName string

	schemaTemplate string
	framework      string
	language       string
	components     []string

	fromExample string

	langMap = map[string]string{
		"ts":         "ts",
		"golang":     "go",
		"typescript": "ts",
		"go":         "go",
		"java":       "java",
	}

	ErrUnknownExample = fmt.Errorf("unknown example name")
)

func getCollections(ctx context.Context, dbName string, format string) ([]*api.CollectionDescription, error) {
	log.Debug().Str("project", dbName).Msg("get list of the collections")

	resp, err := client.Get().DescribeDatabase(ctx, dbName, &driver.DescribeProjectOptions{SchemaFormat: format})
	if err != nil {
		return nil, util.Error(err, "describe collection failed")
	}

	return resp.Collections, nil
}

func getCollectionNames(colls []*api.CollectionDescription) string {
	var s string

	for _, v := range colls {
		if s != "" {
			s += ", "
		}

		s += v.Collection
	}

	return s
}

func getAppKeyForTemplate(ctx context.Context, pName string) (string, string, error) {
	if config.DefaultConfig.Token != "" || config.DefaultConfig.ClientSecret != "" {
		app, err := getAppKey(ctx, pName+"_dev_key")
		if err != nil {
			if !errors.Is(err, ErrAppNotFound) {
				return "", "", util.Error(err, "get app key failed")
			} else if app, err = client.Get().CreateAppKey(ctx,
				pName, pName+"_dev_key", "Generated by the CLI"); err != nil {
				return "", "", err
			}

			log.Debug().Str("name", app.Name).Str("client_id", app.Id).Msg("created new app key")
		}

		log.Debug().Str("name", app.Name).Str("client_id", app.Id).Msg("using app key")

		return app.Id, app.Secret, nil
	}

	return "", "", nil
}

func scaffoldFramework(ctx context.Context, templatesPath string, examplesPath string, pName string) error {
	util.Infof("Generating application code for project '%s'", pName)

	path := templatesPath

	switch {
	case fromExample != "":
		path = examplesPath

		util.Infof("Based on: %s example", fromExample)
	case schemaTemplate != "":
		_, err := client.Get().CreateProject(ctx, pName)
		_ = util.Error(err, "create project")

		util.Infof("Schema template '%s'", schemaTemplate)

		_ = util.Error(scaffold.Schema(ctx, pName, templatesPath, schemaTemplate, true, false),
			"bootstrapping schema: %s", schemaTemplate)
	case framework != "":
		util.Infof("Generating from existing database")
	}

	util.Infof("Language '%s'", language)
	util.Infof("Output directory '%s'", filepath.Join(outDir, pName))

	colls, err := getCollections(ctx, pName, language+",json")
	if err != nil {
		return err
	}

	if framework != "" {
		util.Infof("Package name '%s'", pkgName)
		util.Infof("Framework '%s'", framework)
		util.Infof("Collections [%s]", getCollectionNames(colls))
	}

	clientID, clientSecret, err := getAppKeyForTemplate(ctx, pName)
	if err != nil {
		return err
	}

	scaffold.Project(&scaffold.Config{
		TemplatesPath:   path,
		OutputDirectory: outDir,
		PackageName:     pkgName,
		ProjectName:     pName,
		Example:         fromExample,
		Framework:       framework,
		Components:      components,
		Collections:     colls,
		Language:        language,
		URL:             config.DefaultConfig.URL,
		ClientID:        clientID,
		ClientSecret:    clientSecret,
	})

	return nil
}

func scaffoldProject(ctx context.Context) error {
	language = langMap[strings.ToLower(language)]
	if language == "" {
		util.Fatal(scaffold.ErrUnsupportedFormat, "unsupported language: %s", language)
	}

	var examplesPath string
	if fromExample != "" {
		examplesPath = scaffold.EnsureLocalExamples(language)
		fromExample = strings.ToLower(fromExample)

		if list := util.ListDir(examplesPath); !list[fromExample] {
			util.Infof("Available examples for language '%s': ", language)

			for k := range list {
				util.Infof("\t* %s", k)
			}

			util.Infof("") // newline
			util.Fatal(ErrUnknownExample, "unknown example %s", fromExample)
		}
	}

	var templatesPath string
	if schemaTemplate != "" || framework != "" {
		templatesPath = scaffold.EnsureLocalTemplates()
	}

	pName := config.GetProjectName()

	if pkgName == "" {
		pkgName = pName
	}

	return scaffoldFramework(ctx, templatesPath, examplesPath, pName)
}

var scaffoldProjectCmd = &cobra.Command{
	Use:   "scaffold",
	Short: "Scaffold new application for project",
	Args:  cobra.NoArgs,
	Example: fmt.Sprintf(`
	# Create Tigris project with no collections
	%[1]s %[2]s 

	# Scaffold application code using TypeSript, Express framework' and existing collections schema
	%[1]s %[2]s --framework=express

	# Bootstrap collections from the schema template
	%[1]s %[2]s --schema-template todo

	# Both bootstrap collections and scaffold Express application
	%[1]s %[2]s --schema-template todo --framework=express
`, rootCmd.Root().Name(), "scaffold --project=proj_name"),
	Run: func(cmd *cobra.Command, args []string) {
		login.Ensure(cmd.Context(), scaffoldProject)
	},
}

func addScaffoldProjectFlags(cmd *cobra.Command) {
	cmd.PersistentFlags().StringVarP(&outDir, "output-directory", "o", ".",
		"Directory where to create the scaffolded application. The project name will be appended to this directory path")

	cmd.PersistentFlags().StringVarP(&pkgName, "package-name", "n", "",
		"Package name of the scaffolded project")

	cmd.Flags().StringVarP(&fromExample, "example", "e", "",
		"Scaffold the project from the existing example")

	cmd.Flags().StringVarP(&schemaTemplate, "schema-template", "s", "",
		"Database schema template to use")
	cmd.Flags().StringVarP(&language, "language", "l", "typescript",
		"Language to Scaffold the project in. Possible values are: TypeScript, Golang, Java")
	cmd.Flags().StringVarP(&framework, "framework", "f", "",
		"Framework used for scaffolding")

	cmd.Flags().StringSliceVarP(&components, "components", "c", []string{},
		"Components of the project")
}

func init() {
	addProjectFlag(scaffoldProjectCmd)
	addScaffoldProjectFlags(scaffoldProjectCmd)

	rootCmd.AddCommand(scaffoldProjectCmd)
}
