// Copyright 2022 Tigris Data, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"context"
	"errors"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/tigrisdata/tigris-cli/client"
	"github.com/tigrisdata/tigris-cli/config"
	"github.com/tigrisdata/tigris-cli/scaffold"
	"github.com/tigrisdata/tigris-cli/util"
	api "github.com/tigrisdata/tigris-client-go/api/server/v1"
	"github.com/tigrisdata/tigris-client-go/driver"
)

var (
	outDir  string
	pkgName string

	template  string
	framework string
	language  string

	langMap = map[string]string{
		"ts":         "typescript",
		"golang":     "go",
		"typescript": "typescript",
		"go":         "go",
		"java":       "java",
	}
)

func getCollections(ctx context.Context, dbName string, format string) ([]*api.CollectionDescription, error) {
	resp, err := client.Get().DescribeDatabase(ctx, dbName, &driver.DescribeProjectOptions{SchemaFormat: format})
	if err != nil {
		return nil, util.Error(err, "describe collection failed")
	}

	return resp.Collections, nil
}

func getCollectionNames(colls []*api.CollectionDescription) string {
	var s string

	for _, v := range colls {
		if s != "" {
			s += ", "
		}

		s += v.Collection
	}

	return s
}

func scaffoldProject(ctx context.Context, pName string) error {
	lang := langMap[strings.ToLower(language)]
	if lang == "" {
		util.Fatal(scaffold.ErrUnsupportedFormat, "unsupported language: %s", language)
	}

	if pkgName == "" {
		pkgName = pName
	}

	colls, err := getCollections(ctx, pName, lang+",json")
	if err != nil {
		return err
	}

	util.Infof("Generating application code for project '%s'", pName)

	if template == "" {
		util.Infof("Generating from existing database")
		util.Infof("Collections [%s]", getCollectionNames(colls))
	} else {
		util.Infof("Schema template '%s'", template)
	}

	util.Infof("Framework '%s'", framework)
	util.Infof("Language '%s'", lang)
	util.Infof("Package name '%s'", pkgName)
	util.Infof("Output directory '%s'", filepath.Join(outDir, pName))

	var clientID, clientSecret string

	if config.DefaultConfig.Token != "" || config.DefaultConfig.ClientSecret != "" {
		app, err := getApplication(ctx, pName+"_dev_key")
		if err != nil {
			if !errors.Is(err, ErrAppNotFound) {
				return util.Error(err, "get application key failed")
			} else if app, err = client.Get().CreateAppKey(ctx,
				pName, pName+"_dev_key", "Generated by the CLI"); err != nil {
				return err
			}

			log.Debug().Str("name", app.Name).Str("client_id", app.Id).Msg("created new application key")
		}

		log.Debug().Str("name", app.Name).Str("client_id", app.Id).Msg("using application key")

		clientID = app.Id
		clientSecret = app.Secret
	}

	scaffold.Project(outDir, pkgName, pName, framework, colls, lang, clientID, clientSecret)

	return nil
}

var scaffoldProjectCmd = &cobra.Command{
	Use:   "scaffold",
	Short: "Scaffold new application for project",
	Args:  cobra.NoArgs,
	Run: func(cmd *cobra.Command, args []string) {
		withLogin(cmd.Context(), func(ctx context.Context) error {
			pName := getProjectName()

			if template != "" {
				if err := scaffold.Schema(ctx, pName, template, true, false); err != nil {
					return util.Error(err, "bootstrapping schema: %s", template)
				}
			}

			if framework != "" {
				return scaffoldProject(ctx, pName)
			}

			return nil
		})
	},
}

func addScaffoldProjectFlags(cmd *cobra.Command) {
	cmd.PersistentFlags().StringVarP(&outDir, "output-directory", "o", ".",
		"Directory where to create the scaffolded application. The project name will be appended to this directory path")

	cmd.PersistentFlags().StringVarP(&pkgName, "package-name", "n", "",
		"Package name of the scaffolded project")

	cmd.Flags().StringVarP(&template, "template", "t", "",
		"Project template to use")
	cmd.Flags().StringVarP(&language, "language", "l", "typescript",
		"Language to Scaffold the project in. Possible values are: TypeScript, Golang, Java")
	cmd.Flags().StringVarP(&framework, "framework", "f", "",
		"Type of the project to scaffold")
}

func init() {
	addProjectFlag(scaffoldProjectCmd)
	addScaffoldProjectFlags(scaffoldProjectCmd)

	rootCmd.AddCommand(scaffoldProjectCmd)
}
